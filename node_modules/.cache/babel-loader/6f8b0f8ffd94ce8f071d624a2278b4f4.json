{"ast":null,"code":"'use strict'; // glorious streaming json parser, built specifically for the twitter streaming api\n// assumptions:\n//   1) ninjas are mammals\n//   2) tweets come in chunks of text, surrounded by {}'s, separated by line breaks\n//   3) only one tweet per chunk\n//\n//   p = new parser.instance()\n//   p.addListener('object', function...)\n//   p.receive(data)\n//   p.receive(data)\n//   ...\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Parser = module.exports = function Parser() {\n  // Make sure we call our parents constructor\n  EventEmitter.call(this);\n  this.buffer = '';\n  return this;\n}; // The parser emits events!\n\n\nParser.prototype = Object.create(EventEmitter.prototype);\nParser.END = '\\r\\n';\nParser.END_LENGTH = 2;\n\nParser.prototype.receive = function receive(buffer) {\n  this.buffer += buffer.toString('utf8');\n  var index, json; // We have END?\n\n  while ((index = this.buffer.indexOf(Parser.END)) > -1) {\n    json = this.buffer.slice(0, index);\n    this.buffer = this.buffer.slice(index + Parser.END_LENGTH);\n\n    if (json.length > 0) {\n      try {\n        json = JSON.parse(json); // Event message\n\n        if (json.event !== undefined) {\n          // First emit specific event\n          this.emit(json.event, json); // Now emit catch-all event\n\n          this.emit('event', json);\n        } // Delete message\n        else if (json.delete !== undefined) {\n            this.emit('delete', json);\n          } // Friends message (beginning of stream)\n          else if (json.friends !== undefined || json.friends_str !== undefined) {\n              this.emit('friends', json);\n            } // Any other message\n            else {\n                this.emit('data', json);\n              }\n      } catch (error) {\n        error.source = json;\n        this.emit('error', error);\n      }\n    } else {\n      // Keep Alive\n      this.emit('ping');\n    }\n  }\n};","map":{"version":3,"sources":["/Users/john/Downloads/tennis-react/react-tennis/node_modules/twitter/lib/parser.js"],"names":["EventEmitter","require","Parser","module","exports","call","buffer","prototype","Object","create","END","END_LENGTH","receive","toString","index","json","indexOf","slice","length","JSON","parse","event","undefined","emit","delete","friends","friends_str","error","source"],"mappings":"AAAA,a,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAArC;;AAEA,IAAIE,MAAM,GAAGC,MAAM,CAACC,OAAP,GAAiB,SAASF,MAAT,GAAkB;AAC9C;AACAF,EAAAA,YAAY,CAACK,IAAb,CAAkB,IAAlB;AACA,OAAKC,MAAL,GAAc,EAAd;AACA,SAAO,IAAP;AACD,CALD,C,CAOA;;;AACAJ,MAAM,CAACK,SAAP,GAAmBC,MAAM,CAACC,MAAP,CAAcT,YAAY,CAACO,SAA3B,CAAnB;AAEAL,MAAM,CAACQ,GAAP,GAAoB,MAApB;AACAR,MAAM,CAACS,UAAP,GAAoB,CAApB;;AAEAT,MAAM,CAACK,SAAP,CAAiBK,OAAjB,GAA2B,SAASA,OAAT,CAAiBN,MAAjB,EAAyB;AAClD,OAAKA,MAAL,IAAeA,MAAM,CAACO,QAAP,CAAgB,MAAhB,CAAf;AACA,MAAIC,KAAJ,EAAWC,IAAX,CAFkD,CAIlD;;AACA,SAAO,CAACD,KAAK,GAAG,KAAKR,MAAL,CAAYU,OAAZ,CAAoBd,MAAM,CAACQ,GAA3B,CAAT,IAA4C,CAAC,CAApD,EAAuD;AACrDK,IAAAA,IAAI,GAAG,KAAKT,MAAL,CAAYW,KAAZ,CAAkB,CAAlB,EAAqBH,KAArB,CAAP;AACA,SAAKR,MAAL,GAAc,KAAKA,MAAL,CAAYW,KAAZ,CAAkBH,KAAK,GAAGZ,MAAM,CAACS,UAAjC,CAAd;;AACA,QAAII,IAAI,CAACG,MAAL,GAAc,CAAlB,EAAqB;AACnB,UAAI;AACFH,QAAAA,IAAI,GAAGI,IAAI,CAACC,KAAL,CAAWL,IAAX,CAAP,CADE,CAEF;;AACA,YAAIA,IAAI,CAACM,KAAL,KAAeC,SAAnB,EAA8B;AAC5B;AACA,eAAKC,IAAL,CAAUR,IAAI,CAACM,KAAf,EAAsBN,IAAtB,EAF4B,CAG5B;;AACA,eAAKQ,IAAL,CAAU,OAAV,EAAmBR,IAAnB;AACD,SALD,CAMA;AANA,aAOK,IAAIA,IAAI,CAACS,MAAL,KAAgBF,SAApB,EAA+B;AAClC,iBAAKC,IAAL,CAAU,QAAV,EAAoBR,IAApB;AACD,WAFI,CAGL;AAHK,eAIA,IAAIA,IAAI,CAACU,OAAL,KAAiBH,SAAjB,IAA8BP,IAAI,CAACW,WAAL,KAAqBJ,SAAvD,EAAkE;AACrE,mBAAKC,IAAL,CAAU,SAAV,EAAqBR,IAArB;AACD,aAFI,CAGL;AAHK,iBAIA;AACH,qBAAKQ,IAAL,CAAU,MAAV,EAAkBR,IAAlB;AACD;AACF,OArBD,CAsBA,OAAOY,KAAP,EAAc;AACZA,QAAAA,KAAK,CAACC,MAAN,GAAeb,IAAf;AACA,aAAKQ,IAAL,CAAU,OAAV,EAAmBI,KAAnB;AACD;AACF,KA3BD,MA4BK;AACH;AACA,WAAKJ,IAAL,CAAU,MAAV;AACD;AACF;AACF,CAzCD","sourcesContent":["'use strict';\n\n// glorious streaming json parser, built specifically for the twitter streaming api\n// assumptions:\n//   1) ninjas are mammals\n//   2) tweets come in chunks of text, surrounded by {}'s, separated by line breaks\n//   3) only one tweet per chunk\n//\n//   p = new parser.instance()\n//   p.addListener('object', function...)\n//   p.receive(data)\n//   p.receive(data)\n//   ...\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Parser = module.exports = function Parser() {\n  // Make sure we call our parents constructor\n  EventEmitter.call(this);\n  this.buffer = '';\n  return this;\n};\n\n// The parser emits events!\nParser.prototype = Object.create(EventEmitter.prototype);\n\nParser.END        = '\\r\\n';\nParser.END_LENGTH = 2;\n\nParser.prototype.receive = function receive(buffer) {\n  this.buffer += buffer.toString('utf8');\n  var index, json;\n\n  // We have END?\n  while ((index = this.buffer.indexOf(Parser.END)) > -1) {\n    json = this.buffer.slice(0, index);\n    this.buffer = this.buffer.slice(index + Parser.END_LENGTH);\n    if (json.length > 0) {\n      try {\n        json = JSON.parse(json);\n        // Event message\n        if (json.event !== undefined) {\n          // First emit specific event\n          this.emit(json.event, json);\n          // Now emit catch-all event\n          this.emit('event', json);\n        }\n        // Delete message\n        else if (json.delete !== undefined) {\n          this.emit('delete', json);\n        }\n        // Friends message (beginning of stream)\n        else if (json.friends !== undefined || json.friends_str !== undefined) {\n          this.emit('friends', json);\n        }\n        // Any other message\n        else {\n          this.emit('data', json);\n        }\n      }\n      catch (error) {\n        error.source = json;\n        this.emit('error', error);\n      }\n    }\n    else {\n      // Keep Alive\n      this.emit('ping');\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}